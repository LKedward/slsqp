<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
   
   <meta name="description" content="Modern Fortran Implementation of the SLSQP Optimization Method">
    
    <meta name="author" content="Jacob Williams" >
    <link rel="icon" href="../favicon.png">

    <title>bvls &ndash; slsqp</title>

    <link href="../css/bootstrap.min.css" rel="stylesheet">
    <link href="../css/pygments.css" rel="stylesheet">
    <link href="../css/font-awesome.min.css" rel="stylesheet">
    <link href="../css/local.css" rel="stylesheet">
    
    <link  href="../tipuesearch/tipuesearch.css" rel="stylesheet">
    
    

    <!-- HTML5 shim and Respond.js for IE8 support of HTML5 elements and media queries -->
    <!--[if lt IE 9]>
      <script src="https://oss.maxcdn.com/html5shiv/3.7.2/html5shiv.min.js"></script>
      <script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
    <![endif]-->
    
    <script src="../js/jquery-2.1.3.min.js"></script>
    <script src="../js/svg-pan-zoom.min.js"></script>

  </head>

  <body>

    <!-- Fixed navbar -->
    <nav class="navbar navbar-inverse navbar-fixed-top">
      <div class="container">
        <div class="navbar-header">
          <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar" aria-expanded="false" aria-controls="navbar">
            <span class="sr-only">Toggle navigation</span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
          </button>
          <a class="navbar-brand" href="../index.html">slsqp </a>
        </div>
        <div id="navbar" class="navbar-collapse collapse">
          <ul class="nav navbar-nav">
        
            <li class="dropdown hidden-xs visible-sm visible-md hidden-lg">
              <a href="#" class="dropdown-toggle"
              data-toggle="dropdown" role="button"
              aria-haspopup="true"
     aria-expanded="false">Contents <span class="caret"></span></a>
        <ul class="dropdown-menu">
          
              
            <li><a href="../lists/files.html">Source Files</a></li>
        
        
        
            <li><a href="../lists/modules.html">Modules</a></li>
        
            
                                
            <li><a href="../lists/procedures.html">Procedures</a></li>
        
        
            <li><a href="../lists/absint.html">Abstract Interfaces</a></li>
               
            <li><a href="../lists/types.html">Derived Types</a></li>
        
        
            </ul>
            </li>


<li class="visible-xs hidden-sm visible-lg"><a href="../lists/files.html">Source Files</a></li>



<li class="visible-xs hidden-sm visible-lg"><a href="../lists/modules.html">Modules</a></li>



<li class="visible-xs hidden-sm visible-lg"><a href="../lists/procedures.html">Procedures</a></li>


<li class="visible-xs hidden-sm visible-lg"><a href="../lists/absint.html">Abstract Interfaces</a></li>
                             
<li class="visible-xs hidden-sm visible-lg"><a href="../lists/types.html">Derived Types</a></li>


          </ul>
        
        <form action="../search.html" class="navbar-form navbar-right" role="search">
        <div class="form-group">
          <input type="text" class="form-control" placeholder="Search" name="q" id="tipue_search_input" autocomplete="off" required>
        </div>
<!--
        <button type="submit" class="btn btn-default">Submit</button>
-->
        </form>
        
        </div><!--/.nav-collapse -->
      </div>
    </nav>

    <div class="container">
    
  
  <div class="row">
    <h1>bvls
      <small>Subroutine</small>
    
    </h1>
    
<div class="row">
  <div class="col-lg-12">
<div class="well well-sm">
  <ul class="list-inline" style="margin-bottom:0px;display:inline">
     
     
     
     
    
    
     <li><i class="fa fa-list-ol"></i>
       <a data-toggle="tooltip"
    data-placement="bottom" data-html="true"
    title="15.9% of total for procedures.">337 statements</a>
     </li> 
     
     
     
    <li><i class="fa fa-code"></i><a href="../src/bvls_module.f90"> Source File</a></li>
     
     
  </ul>
  <ol class="breadcrumb in-well text-right">
  
    
     <li><a href='../sourcefile/bvls_module.f90.html'>bvls_module.f90</a></li>
    
     <li><a href='../module/bvls_module.html'>bvls_module</a></li>
    
  
     <li class="active">bvls</li>
  </ol>
</div>
</div>
</div>
<script>
  $(function () {
  $('[data-toggle="tooltip"]').tooltip()
  })
</script>

  </div>
  
  <div class="row">
    <div class="col-md-3 hidden-xs hidden-sm visible-md visible-lg">
    
<div id="sidebar">
  
<h3>Contents</h3>
 





















<div class="panel panel-primary">
  <div class="panel-heading text-left"><h3 class="panel-title">Source Code</h3></div>
  <div class="list-group">
    <a class="list-group-item" href="../proc/bvls.html#src">bvls</a>
  </div>
</div>



</div>

    </div>
    
    <div class="col-md-9" id='text'>
    <h2>
public subroutine bvls(a, b, bnd, x, rnorm, nsetp, w, index, ierr, max_iter)
    
    
   
</h2>
    
  


    
    <p>Given an m by n matrix, <script type="math/tex">\mathbf{A}</script>, and an m-vector, <script type="math/tex">\mathbf{b}</script>,
  compute an n-vector, <script type="math/tex">\mathbf{x}</script>, that solves the least squares problem:</p>
<p>
<script type="math/tex"> \mathbf{A} \mathbf{x} = \mathbf{b}</script>
</p>
<p>subject to <script type="math/tex"> \mathbf{x} </script> satisfying:</p>
<p>
<script type="math/tex"> \mathbf{x}_l \le \mathbf{x} \le \mathbf{x}_u </script>
</p>
<p>This algorithm is a generalization of <a href="../proc/nnls.html">nnls</a>, that solves
  the least-squares problem, <code>A * X = B</code>, subject to all <code>X(J) &gt;= 0</code>.</p>
<h3>History</h3>
<ul>
<li>The subroutine <a href="../proc/nnls.html">nnls</a> appeared in 'Solving least squares problems,'
    by Lawson and Hanson, Prentice-Hall, 1974.  Work on BVLS was started
    by C. L. Lawson and R. J. Hanson at Jet Propulsion Laboratory,
    1973 June 12.  Many modifications were subsequently made.
    This Fortran 90 code was completed in April, 1995 by R. J. Hanson.</li>
</ul>
    

    <h3>Arguments</h3>
    
      
<table class="table table-striped varlist">
<thead><tr><th>Type</th>
<th>Intent</th><th>Optional</th>
<th>Attributes</th><th></th><th>Name</th><th></th></thead>



<tbody>

  
  
  
  
<tr>
  
  <td><span class="anchor" id="variable-a%7E12"></span>real(kind=wp),</td>
  <td>intent(inout),</td>
  <td></td>
  
  <td>dimension(:,:)</td><td>::</td>
  <td><strong>a</strong></td><td><p>On entry A() contains the M by N matrix, A.
 On return A() contains the product matrix, Q*A, where
 Q is an M by M orthogonal matrix generated by this
 subroutine.  The dimensions are M=size(A,1) and N=size(A,2).</p></td>
  
</tr>

  
  
  
  
<tr>
  
  <td><span class="anchor" id="variable-b%7E8"></span>real(kind=wp),</td>
  <td>intent(inout),</td>
  <td></td>
  
  <td>dimension(:)</td><td>::</td>
  <td><strong>b</strong></td><td><p>On entry B() contains the M-vector, B.
 On return, B() contains Q*B.  The same Q multiplies A.</p></td>
  
</tr>

  
  
  
  
<tr>
  
  <td><span class="anchor" id="variable-bnd"></span>real(kind=wp),</td>
  <td>intent(in),</td>
  <td></td>
  
  <td>dimension(:,:)</td><td>::</td>
  <td><strong>bnd</strong></td><td><p>BND(1,J) is the lower bound for X(J).
 BND(2,J) is the upper bound for X(J).</p>
<p>Require:  BND(1,J)  &lt;=  BND(2,J).</p>
<p>The values BND(1,J) = -huge(ONE) and BND(2,J) = huge(ONE) are
 suggested choices to designate that there is no constraint in that
 direction.  The parameter ONE is 1.0 in the working precision.</p></td>
  
</tr>

  
  
  
  
<tr>
  
  <td><span class="anchor" id="variable-x%7E18"></span>real(kind=wp),</td>
  <td>intent(out),</td>
  <td></td>
  
  <td>dimension(:)</td><td>::</td>
  <td><strong>x</strong></td><td><p>On entry X() need not be initialized.  On return,
 X() will contain the solution N-vector.</p></td>
  
</tr>

  
  
  
  
<tr>
  
  <td><span class="anchor" id="variable-rnorm%7E4"></span>real(kind=wp),</td>
  <td>intent(out)</td>
  <td></td>
  
  <td></td><td>::</td>
  <td><strong>rnorm</strong></td><td><p>Euclidean norm of the residual vector, b - A*X.</p></td>
  
</tr>

  
  
  
  
<tr>
  
  <td><span class="anchor" id="variable-nsetp"></span>integer,</td>
  <td>intent(out)</td>
  <td></td>
  
  <td></td><td>::</td>
  <td><strong>nsetp</strong></td><td><p>Indicates the number of components of the solution
 vector, X(), that are not at their constraint values.</p></td>
  
</tr>

  
  
  
  
<tr>
  
  <td><span class="anchor" id="variable-w%7E13"></span>real(kind=wp),</td>
  <td>intent(out),</td>
  <td></td>
  
  <td>dimension(:)</td><td>::</td>
  <td><strong>w</strong></td><td><p>An N-array.  On return, W() will contain the dual solution
 vector.   Using Set definitions below:</p>
<ul>
<li>W(J) = 0 for all j in Set P,</li>
<li>W(J)  &lt;=  0 for all j in Set Z, such that X(J) is at its
   lower bound, and</li>
<li>W(J)  &gt;=  0 for all j in Set Z, such that X(J) is at its
   upper bound.</li>
</ul>
<p>If BND(1,J) = BND(2,J), so the variable X(J) is fixed,
 then W(J) will have an arbitrary value.</p></td>
  
</tr>

  
  
  
  
<tr>
  
  <td><span class="anchor" id="variable-index"></span>integer,</td>
  <td>intent(out),</td>
  <td></td>
  
  <td>dimension(:)</td><td>::</td>
  <td><strong>index</strong></td><td><p>An INTEGER working array of size N.  On exit the contents
 of this array define the sets P, Z, and F as follows:</p>
<ul>
<li>INDEX(1)   through INDEX(NSETP)    =  Set P.</li>
<li>INDEX(IZ1) through INDEX(IZ2)      = Set Z.</li>
<li>INDEX(IZ2+1) through INDEX(N)      = Set F.</li>
</ul>
<p>IZ1 = NSETP + 1 = NPP1</p>
<p>Any of these sets may be empty.  Set F is those components
 that are constrained to a unique value by the given
 constraints.   Sets P and Z are those that are allowed a non-
 zero range of values.  Of these, set Z are those whose final
 value is a constraint value, while set P are those whose
 final value is not a constraint.  The value of IZ2 is not returned.</p>
<p>It is computable as the number of bounds constraining a component
 of X uniquely.</p></td>
  
</tr>

  
  
  
  
<tr>
  
  <td><span class="anchor" id="variable-ierr"></span>integer,</td>
  <td>intent(out)</td>
  <td></td>
  
  <td></td><td>::</td>
  <td><strong>ierr</strong></td><td><p>Indicates status on return:</p>
<ul>
<li>0 -- Solution completed.</li>
<li>1 -- M  &lt;=  0 or N  &lt;=  0</li>
<li>2 -- B(:), X(:), BND(:,:), W(:), or INDEX(:) size or shape violation.</li>
<li>3 -- Input bounds are inconsistent.</li>
<li>4 -- Exceed maximum number of iterations.</li>
</ul></td>
  
</tr>

  
  
  
  
<tr>
  
  <td><span class="anchor" id="variable-max_iter%7E5"></span>integer,</td>
  <td>intent(in)</td>
  <td></td>
  
  <td></td><td>::</td>
  <td><strong>max_iter</strong></td><td><p>maximum number of iterations (if &lt;=0, then <code>3*n</code> is used)</p></td>
  
</tr>

</tbody>
</table>

    
    
    
    <br>
    
    
     
    <div class="panel panel-default">
      <div class="panel-heading">
  <h3 class="panel-title">Called by</h3>
      </div>
      <div class="panel-body">
  <div class="depgraph"><?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN"
 "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">
<!-- Generated by graphviz version 2.38.0 (20140413.2041)
 -->
<!-- Title: proc~~bvls~~CalledByGraph Pages: 1 -->
<svg id="procbvlsCalledByGraph" width="178pt" height="32pt"
 viewBox="0.00 0.00 178.00 32.00" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
<g id="proc~~bvls~~CalledByGraph" class="graph" transform="scale(1 1) rotate(0) translate(4 28)">
<title>proc~~bvls~~CalledByGraph</title>
<polygon fill="white" stroke="none" points="-4,4 -4,-28 174,-28 174,4 -4,4"/>
<!-- proc~bvls -->
<g id="proc~~bvls~~CalledByGraph_node1" class="node"><title>proc~bvls</title>
<polygon fill="none" stroke="black" points="170,-24 116,-24 116,-0 170,-0 170,-24"/>
<text text-anchor="middle" x="143" y="-9.6" font-family="Helvetica,sans-Serif" font-size="10.50">bvls</text>
</g>
<!-- proc~bvls_wrapper -->
<g id="proc~~bvls~~CalledByGraph_node2" class="node"><title>proc~bvls_wrapper</title>
<g id="a_proc~~bvls~~CalledByGraph_node2"><a xlink:href=".././proc/bvls_wrapper.html" xlink:title="bvls_wrapper">
<polygon fill="#d9534f" stroke="#d9534f" points="80,-24 0,-24 0,-0 80,-0 80,-24"/>
<text text-anchor="middle" x="40" y="-9.6" font-family="Helvetica,sans-Serif" font-size="10.50" fill="white">bvls_wrapper</text>
</a>
</g>
</g>
<!-- proc~bvls_wrapper&#45;&gt;proc~bvls -->
<g id="proc~~bvls~~CalledByGraph_edge1" class="edge"><title>proc~bvls_wrapper&#45;&gt;proc~bvls</title>
<path fill="none" stroke="#000000" d="M80.0492,-12C88.4799,-12 97.36,-12 105.681,-12"/>
<polygon fill="#000000" stroke="#000000" points="105.846,-15.5001 115.846,-12 105.846,-8.5001 105.846,-15.5001"/>
</g>
</g>
</svg>
</div><div><a type="button" class="graph-help" data-toggle="modal" href="#graph-help-text">Help</a></div><div class="modal fade" id="graph-help-text" tabindex="-1" role="dialog"><div class="modal-dialog modal-lg" role="document"><div class="modal-content"><div class="modal-header"><button type="button" class="close" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">&times;</span></button><h4 class="modal-title" id="-graph-help-label">Graph Key</h4></div><div class="modal-body">
    <p>Nodes of different colours represent the following: </p>
    <?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN"
 "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">
<!-- Generated by graphviz version 2.38.0 (20140413.2041)
 -->
<!-- Title: Graph Key Pages: 1 -->
<svg width="590pt" height="32pt"
 viewBox="0.00 0.00 589.50 32.00" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
<g id="graph0" class="graph" transform="scale(1 1) rotate(0) translate(4 28)">
<title>Graph Key</title>
<polygon fill="white" stroke="none" points="-4,4 -4,-28 585.5,-28 585.5,4 -4,4"/>
<!-- Subroutine -->
<g id="node1" class="node"><title>Subroutine</title>
<polygon fill="#d9534f" stroke="#d9534f" points="70,-24 0,-24 0,-0 70,-0 70,-24"/>
<text text-anchor="middle" x="35" y="-9.6" font-family="Helvetica,sans-Serif" font-size="10.50" fill="white">Subroutine</text>
</g>
<!-- Function -->
<g id="node2" class="node"><title>Function</title>
<polygon fill="#d94e8f" stroke="#d94e8f" points="145.5,-24 88.5,-24 88.5,-0 145.5,-0 145.5,-24"/>
<text text-anchor="middle" x="117" y="-9.6" font-family="Helvetica,sans-Serif" font-size="10.50" fill="white">Function</text>
</g>
<!-- Interface -->
<g id="node3" class="node"><title>Interface</title>
<polygon fill="#a7506f" stroke="#a7506f" points="222,-24 164,-24 164,-0 222,-0 222,-24"/>
<text text-anchor="middle" x="193" y="-9.6" font-family="Helvetica,sans-Serif" font-size="10.50" fill="white">Interface</text>
</g>
<!-- Unknown Procedure Type -->
<g id="node4" class="node"><title>Unknown Procedure Type</title>
<polygon fill="#777777" stroke="#777777" points="385.5,-24 240.5,-24 240.5,-0 385.5,-0 385.5,-24"/>
<text text-anchor="middle" x="313" y="-9.6" font-family="Helvetica,sans-Serif" font-size="10.50" fill="white">Unknown Procedure Type</text>
</g>
<!-- Program -->
<g id="node5" class="node"><title>Program</title>
<polygon fill="#f0ad4e" stroke="#f0ad4e" points="460,-24 404,-24 404,-0 460,-0 460,-24"/>
<text text-anchor="middle" x="432" y="-9.6" font-family="Helvetica,sans-Serif" font-size="10.50" fill="white">Program</text>
</g>
<!-- This Page&#39;s Entity -->
<g id="node6" class="node"><title>This Page&#39;s Entity</title>
<polygon fill="none" stroke="black" points="581.5,-24 478.5,-24 478.5,-0 581.5,-0 581.5,-24"/>
<text text-anchor="middle" x="530" y="-9.6" font-family="Helvetica,sans-Serif" font-size="10.50">This Page&#39;s Entity</text>
</g>
</g>
</svg>

    
    <p>Solid arrows point from a procedure to one which it calls. Dashed 
    arrows point from an interface to procedures which implement that interface.
    This could include the module procedures in a generic interface or the
    implementation in a submodule of an interface in a parent module.
    </p>
    </div></div></div></div>
      </div>
    </div>
     
    <br>

    <section class="visible-xs visible-sm hidden-md">
      
<h3>Contents</h3>
 





















<div class="panel panel-primary">
  <div class="panel-heading text-left"><h3 class="panel-title">Source Code</h3></div>
  <div class="list-group">
    <a class="list-group-item" href="../proc/bvls.html#src">bvls</a>
  </div>
</div>



    </section>
    <br class="visible-xs visible-sm hidden-md">

    

    
    
    
    
    

    
    
    
    
    


    
    
    
    <section>
    <h2><span class="anchor" id="src"></span>Source Code</h2>
    <div class="highlight"><pre><span></span>    <span class="k">subroutine </span><span class="n">bvls</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">bnd</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">rnorm</span><span class="p">,</span> <span class="n">nsetp</span><span class="p">,</span> <span class="n">w</span><span class="p">,</span> <span class="nb">index</span><span class="p">,</span> <span class="n">ierr</span><span class="p">,</span> <span class="n">max_iter</span><span class="p">)</span>

    <span class="k">implicit none</span>

<span class="k">    </span><span class="kt">real</span><span class="p">(</span><span class="n">wp</span><span class="p">),</span><span class="k">dimension</span><span class="p">(:,:),</span><span class="k">intent</span><span class="p">(</span><span class="n">inout</span><span class="p">)</span> <span class="kd">::</span> <span class="n">a</span>  <span class="c">!! On entry A() contains the M by N matrix, A.</span>
                                                <span class="c">!! On return A() contains the product matrix, Q*A, where</span>
                                                <span class="c">!! Q is an M by M orthogonal matrix generated by this</span>
                                                <span class="c">!! subroutine.  The dimensions are M=size(A,1) and N=size(A,2).</span>
    <span class="kt">real</span><span class="p">(</span><span class="n">wp</span><span class="p">),</span><span class="k">dimension</span><span class="p">(:),</span><span class="k">intent</span><span class="p">(</span><span class="n">inout</span><span class="p">)</span>   <span class="kd">::</span> <span class="n">b</span>  <span class="c">!! On entry B() contains the M-vector, B.</span>
                                                <span class="c">!! On return, B() contains Q*B.  The same Q multiplies A.</span>
    <span class="kt">real</span><span class="p">(</span><span class="n">wp</span><span class="p">),</span><span class="k">dimension</span><span class="p">(:,:),</span><span class="k">intent</span><span class="p">(</span><span class="n">in</span><span class="p">)</span> <span class="kd">::</span> <span class="n">bnd</span>   <span class="c">!! BND(1,J) is the lower bound for X(J).</span>
                                                <span class="c">!! BND(2,J) is the upper bound for X(J).</span>
                                                <span class="c">!!</span>
                                                <span class="c">!! Require:  BND(1,J)  &lt;=  BND(2,J).</span>
                                                <span class="c">!!</span>
                                                <span class="c">!! The values BND(1,J) = -huge(ONE) and BND(2,J) = huge(ONE) are</span>
                                                <span class="c">!! suggested choices to designate that there is no constraint in that</span>
                                                <span class="c">!! direction.  The parameter ONE is 1.0 in the working precision.</span>
    <span class="kt">real</span><span class="p">(</span><span class="n">wp</span><span class="p">),</span><span class="k">dimension</span><span class="p">(:),</span><span class="k">intent</span><span class="p">(</span><span class="n">out</span><span class="p">)</span>   <span class="kd">::</span> <span class="n">x</span>    <span class="c">!! On entry X() need not be initialized.  On return,</span>
                                                <span class="c">!! X() will contain the solution N-vector.</span>
    <span class="kt">real</span><span class="p">(</span><span class="n">wp</span><span class="p">),</span><span class="k">intent</span><span class="p">(</span><span class="n">out</span><span class="p">)</span>                <span class="kd">::</span> <span class="n">rnorm</span> <span class="c">!! Euclidean norm of the residual vector, b - A*X.</span>
    <span class="kt">integer</span><span class="p">,</span><span class="k">intent</span><span class="p">(</span><span class="n">out</span><span class="p">)</span>                 <span class="kd">::</span> <span class="n">nsetp</span> <span class="c">!! Indicates the number of components of the solution</span>
                                                 <span class="c">!! vector, X(), that are not at their constraint values.</span>
    <span class="kt">real</span><span class="p">(</span><span class="n">wp</span><span class="p">),</span><span class="k">dimension</span><span class="p">(:),</span><span class="k">intent</span><span class="p">(</span><span class="n">out</span><span class="p">)</span>   <span class="kd">::</span> <span class="n">w</span>    <span class="c">!! An N-array.  On return, W() will contain the dual solution</span>
                                                <span class="c">!! vector.   Using Set definitions below:</span>
                                                <span class="c">!!</span>
                                                <span class="c">!! * W(J) = 0 for all j in Set P,</span>
                                                <span class="c">!! * W(J)  &lt;=  0 for all j in Set Z, such that X(J) is at its</span>
                                                <span class="c">!!   lower bound, and</span>
                                                <span class="c">!! * W(J)  &gt;=  0 for all j in Set Z, such that X(J) is at its</span>
                                                <span class="c">!!   upper bound.</span>
                                                <span class="c">!!</span>
                                                <span class="c">!! If BND(1,J) = BND(2,J), so the variable X(J) is fixed,</span>
                                                <span class="c">!! then W(J) will have an arbitrary value.</span>
    <span class="kt">integer</span><span class="p">,</span><span class="k">dimension</span><span class="p">(:),</span><span class="k">intent</span><span class="p">(</span><span class="n">out</span><span class="p">)</span>    <span class="kd">::</span> <span class="nb">index</span>    <span class="c">!! An INTEGER working array of size N.  On exit the contents</span>
                                                    <span class="c">!! of this array define the sets P, Z, and F as follows:</span>
                                                    <span class="c">!!</span>
                                                    <span class="c">!! * INDEX(1)   through INDEX(NSETP)    =  Set P.</span>
                                                    <span class="c">!! * INDEX(IZ1) through INDEX(IZ2)      = Set Z.</span>
                                                    <span class="c">!! * INDEX(IZ2+1) through INDEX(N)      = Set F.</span>
                                                    <span class="c">!!</span>
                                                    <span class="c">!! IZ1 = NSETP + 1 = NPP1</span>
                                                    <span class="c">!!</span>
                                                    <span class="c">!! Any of these sets may be empty.  Set F is those components</span>
                                                    <span class="c">!! that are constrained to a unique value by the given</span>
                                                    <span class="c">!! constraints.   Sets P and Z are those that are allowed a non-</span>
                                                    <span class="c">!! zero range of values.  Of these, set Z are those whose final</span>
                                                    <span class="c">!! value is a constraint value, while set P are those whose</span>
                                                    <span class="c">!! final value is not a constraint.  The value of IZ2 is not returned.</span>
                                                    <span class="c">!!</span>
                                                    <span class="c">!! It is computable as the number of bounds constraining a component</span>
                                                    <span class="c">!! of X uniquely.</span>
    <span class="kt">integer</span><span class="p">,</span><span class="k">intent</span><span class="p">(</span><span class="n">out</span><span class="p">)</span>                 <span class="kd">::</span> <span class="n">ierr</span> <span class="c">!! Indicates status on return:</span>
                                                <span class="c">!!</span>
                                                <span class="c">!! * 0 -- Solution completed.</span>
                                                <span class="c">!! * 1 -- M  &lt;=  0 or N  &lt;=  0</span>
                                                <span class="c">!! * 2 -- B(:), X(:), BND(:,:), W(:), or INDEX(:) size or shape violation.</span>
                                                <span class="c">!! * 3 -- Input bounds are inconsistent.</span>
                                                <span class="c">!! * 4 -- Exceed maximum number of iterations.</span>
    <span class="kt">integer</span><span class="p">,</span><span class="k">intent</span><span class="p">(</span><span class="n">in</span><span class="p">)</span> <span class="kd">::</span> <span class="n">max_iter</span> <span class="c">!! maximum number of iterations (if &lt;=0, then `3*n` is used)</span>

    <span class="kt">logical</span> <span class="kd">::</span> <span class="n">find</span><span class="p">,</span> <span class="n">hitbnd</span><span class="p">,</span> <span class="n">free1</span><span class="p">,</span> <span class="n">free2</span><span class="p">,</span> <span class="n">free</span>
    <span class="kt">integer</span> <span class="kd">::</span> <span class="n">iter</span>     <span class="c">!! Iteration counter.</span>
    <span class="kt">integer</span> <span class="kd">::</span> <span class="n">itmax</span>    <span class="c">!! Maximum number of iterations permitted.</span>
                        <span class="c">!! Defaults to 3*n if `max_iter&lt;=0`.</span>
                        <span class="c">!! This is usually larger than required.</span>
    <span class="kt">integer</span> <span class="kd">::</span> <span class="n">m</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">ibound</span><span class="p">,</span> <span class="n">ii</span><span class="p">,</span> <span class="n">ip</span><span class="p">,</span> <span class="n">iz</span><span class="p">,</span> <span class="n">iz1</span><span class="p">,</span> <span class="n">iz2</span><span class="p">,</span> <span class="p">&amp;</span>
               <span class="n">j</span><span class="p">,</span> <span class="n">jj</span><span class="p">,</span> <span class="n">jz</span><span class="p">,</span> <span class="n">l</span><span class="p">,</span> <span class="nb">lbound</span><span class="p">,</span> <span class="n">npp1</span>
    <span class="kt">real</span><span class="p">(</span><span class="n">wp</span><span class="p">),</span><span class="k">dimension</span><span class="p">(</span><span class="n">size</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="mi">2</span><span class="p">))</span> <span class="kd">::</span> <span class="n">s</span>
    <span class="kt">real</span><span class="p">(</span><span class="n">wp</span><span class="p">),</span><span class="k">dimension</span><span class="p">(</span><span class="n">size</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="mi">1</span><span class="p">))</span> <span class="kd">::</span> <span class="n">z</span>
    <span class="kt">real</span><span class="p">(</span><span class="n">wp</span><span class="p">)</span> <span class="kd">::</span> <span class="n">alpha</span><span class="p">,</span> <span class="n">asave</span><span class="p">,</span> <span class="n">cc</span><span class="p">,</span> <span class="nb">range</span><span class="p">,</span> <span class="p">&amp;</span>
                <span class="n">norm</span><span class="p">,</span> <span class="n">sm</span><span class="p">,</span> <span class="n">ss</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">unorm</span><span class="p">,</span> <span class="n">up</span><span class="p">,</span> <span class="n">ztest</span>

    <span class="kt">real</span><span class="p">(</span><span class="n">wp</span><span class="p">),</span><span class="k">parameter</span> <span class="kd">::</span> <span class="n">eps</span> <span class="o">=</span> <span class="nb">epsilon</span><span class="p">(</span><span class="n">one</span><span class="p">)</span>  <span class="c">!! Determines the relative linear dependence of a column vector</span>
                                              <span class="c">!! for a variable moved from its initial value.  This is used in</span>
                                              <span class="c">!! one place with the default value EPS=EPSILON(ONE).  Other</span>
                                              <span class="c">!! values, larger or smaller may be needed for some problems.</span>
                                              <span class="c">!! Library software will likely make this an optional argument.</span>

    <span class="k">call </span><span class="n">initialize</span><span class="p">()</span>
    <span class="c">! The above call will set IERR.</span>

    <span class="n">loopa</span><span class="p">:</span> <span class="k">do</span>

        <span class="c">! Quit on error flag, or if all coefficients are already in the</span>
        <span class="c">! solution, .or. if M columns of A have been triangularized.</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">ierr</span> <span class="o">/=</span>  <span class="mi">0</span>  <span class="p">.</span><span class="nb">or</span><span class="p">.</span>  <span class="n">iz1</span>  <span class="o">&gt;</span> <span class="n">iz2</span> <span class="p">.</span><span class="nb">or</span><span class="p">.</span> <span class="n">nsetp</span> <span class="o">&gt;=</span> <span class="n">m</span><span class="p">)</span> <span class="k">exit </span><span class="n">loopa</span>

        <span class="k">call </span><span class="n">select_another_coeff_to_solve_for</span><span class="p">()</span>

        <span class="c">! See if no index was found to be moved from set Z to set P.</span>
        <span class="c">! Then go to termination.</span>
        <span class="k">if</span> <span class="p">(</span> <span class="p">.</span><span class="nb">not</span><span class="p">.</span> <span class="n">find</span> <span class="p">)</span> <span class="k">exit </span><span class="n">loopa</span>

        <span class="k">call </span><span class="n">move_j_from_set_z_to_set_p</span><span class="p">()</span>

        <span class="k">call </span><span class="n">test_set_p_against_constraints</span><span class="p">()</span>

        <span class="c">! The above call may set IERR.</span>
        <span class="c">! All coefficients in set P are strictly feasible.  Loop back.</span>

    <span class="k">end do </span><span class="n">loopa</span>

    <span class="k">call </span><span class="n">termination</span><span class="p">()</span>

<span class="k">contains</span>  <span class="c">! These are internal subroutines.</span>

<span class="k">subroutine </span><span class="n">initialize</span><span class="p">()</span>

   <span class="n">m</span><span class="o">=</span><span class="n">size</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
   <span class="n">n</span><span class="o">=</span><span class="n">size</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>
   <span class="k">if</span> <span class="p">(</span><span class="n">m</span>  <span class="o">&lt;=</span>  <span class="mi">0</span> <span class="p">.</span><span class="nb">or</span><span class="p">.</span> <span class="n">n</span>  <span class="o">&lt;=</span>  <span class="mi">0</span><span class="p">)</span> <span class="k">then</span>
<span class="k">      </span><span class="n">ierr</span> <span class="o">=</span> <span class="mi">1</span>
      <span class="k">return</span>
<span class="k">   end if</span>

   <span class="c">! Check array sizes for consistency and with M and N.</span>
   <span class="k">if</span> <span class="p">(</span><span class="n">size</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">)</span> <span class="k">then</span>
<span class="k">      </span><span class="n">ierr</span><span class="o">=</span><span class="mi">2</span>
      <span class="k">return</span>
<span class="k">   end if</span>
<span class="k">   if</span> <span class="p">(</span><span class="n">size</span><span class="p">(</span><span class="n">b</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">m</span><span class="p">)</span> <span class="k">then</span>
<span class="k">      </span><span class="n">ierr</span><span class="o">=</span><span class="mi">2</span>
      <span class="k">return</span>
<span class="k">   end if</span>
<span class="k">   if</span> <span class="p">(</span><span class="n">size</span><span class="p">(</span><span class="n">bnd</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span> <span class="o">/=</span> <span class="mi">2</span><span class="p">)</span> <span class="k">then</span>
<span class="k">      </span><span class="n">ierr</span><span class="o">=</span><span class="mi">2</span>
      <span class="k">return</span>
<span class="k">   end if</span>
<span class="k">   if</span> <span class="p">(</span><span class="n">size</span><span class="p">(</span><span class="n">bnd</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">)</span> <span class="k">then</span>
<span class="k">      </span><span class="n">ierr</span><span class="o">=</span><span class="mi">2</span>
      <span class="k">return</span>
<span class="k">   end if</span>
<span class="k">   if</span> <span class="p">(</span><span class="n">size</span><span class="p">(</span><span class="n">w</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">)</span> <span class="k">then</span>
<span class="k">      </span><span class="n">ierr</span><span class="o">=</span><span class="mi">2</span>
      <span class="k">return</span>
<span class="k">   end if</span>
<span class="k">   if</span> <span class="p">(</span><span class="n">size</span><span class="p">(</span><span class="nb">index</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">)</span> <span class="k">then</span>
<span class="k">      </span><span class="n">ierr</span><span class="o">=</span><span class="mi">2</span>
      <span class="k">return</span>
<span class="k">   end if</span>

<span class="k">   </span><span class="n">ierr</span> <span class="o">=</span> <span class="mi">0</span>
   <span class="k">if</span> <span class="p">(</span><span class="n">max_iter</span><span class="o">&lt;=</span><span class="mi">0</span><span class="p">)</span> <span class="k">then</span>
<span class="k">      </span><span class="n">itmax</span> <span class="o">=</span> <span class="mi">3</span><span class="o">*</span><span class="n">n</span>
   <span class="k">else</span>
<span class="k">      </span><span class="n">itmax</span> <span class="o">=</span> <span class="n">max_iter</span>
   <span class="k">end if</span>
<span class="k">   </span><span class="n">iter</span><span class="o">=</span><span class="mi">0</span>
   <span class="c">! Initialize the array index().</span>
   <span class="k">do </span><span class="n">i</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span><span class="n">n</span>
      <span class="nb">index</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="o">=</span><span class="n">i</span>
   <span class="k">end do</span>

<span class="k">   </span><span class="n">iz2</span><span class="o">=</span><span class="n">n</span>
   <span class="n">iz1</span><span class="o">=</span><span class="mi">1</span>
   <span class="n">nsetp</span><span class="o">=</span><span class="mi">0</span>
   <span class="n">npp1</span><span class="o">=</span><span class="mi">1</span>

   <span class="c">! Begin:  Loop on IZ to initialize  X().</span>
   <span class="n">iz</span><span class="o">=</span><span class="n">iz1</span>
   <span class="k">do</span>
<span class="k">      if</span> <span class="p">(</span><span class="n">iz</span>  <span class="o">&gt;</span>  <span class="n">iz2</span> <span class="p">)</span> <span class="k">exit</span>
<span class="k">      </span><span class="n">j</span><span class="o">=</span><span class="nb">index</span><span class="p">(</span><span class="n">iz</span><span class="p">)</span>
      <span class="k">if</span> <span class="p">(</span> <span class="n">bnd</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="n">j</span><span class="p">)</span>   <span class="o">&lt;=</span> <span class="o">-</span><span class="nb">huge</span><span class="p">(</span><span class="n">one</span><span class="p">))</span> <span class="k">then</span>
<span class="k">         if</span> <span class="p">(</span><span class="n">bnd</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="n">j</span><span class="p">)</span> <span class="o">&gt;=</span>  <span class="nb">huge</span><span class="p">(</span><span class="n">one</span><span class="p">))</span> <span class="k">then</span>
<span class="k">            </span><span class="n">x</span><span class="p">(</span><span class="n">j</span><span class="p">)</span> <span class="o">=</span> <span class="n">zero</span>
         <span class="k">else</span>
<span class="k">            </span><span class="n">x</span><span class="p">(</span><span class="n">j</span><span class="p">)</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">zero</span><span class="p">,</span><span class="n">bnd</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="n">j</span><span class="p">))</span>
         <span class="k">end if</span>
<span class="k">     else  if</span> <span class="p">(</span> <span class="n">bnd</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="n">j</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="nb">huge</span><span class="p">(</span><span class="n">one</span><span class="p">))</span> <span class="k">then</span>
<span class="k">        </span><span class="n">x</span><span class="p">(</span><span class="n">j</span><span class="p">)</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">zero</span><span class="p">,</span><span class="n">bnd</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="n">j</span><span class="p">))</span>
     <span class="k">else</span>
<span class="k">        </span><span class="nb">range</span> <span class="o">=</span> <span class="n">bnd</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="n">j</span><span class="p">)</span> <span class="o">-</span> <span class="n">bnd</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="n">j</span><span class="p">)</span>
        <span class="k">if</span> <span class="p">(</span> <span class="nb">range</span> <span class="o">&lt;=</span> <span class="n">zero</span> <span class="p">)</span> <span class="k">then</span>
           <span class="c">! Here X(J) is constrained to a single value.</span>
           <span class="nb">index</span><span class="p">(</span><span class="n">iz</span><span class="p">)</span><span class="o">=</span><span class="nb">index</span><span class="p">(</span><span class="n">iz2</span><span class="p">)</span>
           <span class="nb">index</span><span class="p">(</span><span class="n">iz2</span><span class="p">)</span><span class="o">=</span><span class="n">j</span>
           <span class="n">iz</span><span class="o">=</span><span class="n">iz</span><span class="o">-</span><span class="mi">1</span>
           <span class="n">iz2</span><span class="o">=</span><span class="n">iz2</span><span class="o">-</span><span class="mi">1</span>
           <span class="n">x</span><span class="p">(</span><span class="n">j</span><span class="p">)</span><span class="o">=</span><span class="n">bnd</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="n">j</span><span class="p">)</span>
           <span class="n">w</span><span class="p">(</span><span class="n">j</span><span class="p">)</span><span class="o">=</span><span class="n">zero</span>
         <span class="k">else  if</span> <span class="p">(</span> <span class="nb">range</span>  <span class="o">&gt;</span>  <span class="n">zero</span><span class="p">)</span> <span class="k">then</span>
            <span class="c">!! The following statement sets X(J) to 0 if the constraint interval</span>
            <span class="c">!! includes 0, and otherwise sets X(J) to the endpoint of the</span>
            <span class="c">!! constraint interval that is closest to 0.</span>
            <span class="n">x</span><span class="p">(</span><span class="n">j</span><span class="p">)</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">bnd</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="n">j</span><span class="p">),</span> <span class="nb">min</span><span class="p">(</span><span class="n">bnd</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="n">j</span><span class="p">),</span><span class="n">zero</span><span class="p">))</span>
         <span class="k">else</span>
<span class="k">            </span><span class="n">ierr</span> <span class="o">=</span> <span class="mi">3</span>
            <span class="k">return</span>
<span class="k">         end if</span>
<span class="k">   end if</span>
<span class="k">      if</span> <span class="p">(</span> <span class="nb">abs</span><span class="p">(</span><span class="n">x</span><span class="p">(</span><span class="n">j</span><span class="p">))</span> <span class="o">&gt;</span> <span class="n">zero</span> <span class="p">)</span> <span class="k">then</span>
         <span class="c">! Change B() to reflect a nonzero starting value for X(J).</span>
         <span class="n">b</span><span class="p">(</span><span class="mi">1</span><span class="p">:</span><span class="n">m</span><span class="p">)</span><span class="o">=</span><span class="n">b</span><span class="p">(</span><span class="mi">1</span><span class="p">:</span><span class="n">m</span><span class="p">)</span><span class="o">-</span><span class="n">a</span><span class="p">(</span><span class="mi">1</span><span class="p">:</span><span class="n">m</span><span class="p">,</span><span class="n">j</span><span class="p">)</span><span class="o">*</span><span class="n">x</span><span class="p">(</span><span class="n">j</span><span class="p">)</span>
      <span class="k">end if</span>
<span class="k">      </span><span class="n">iz</span><span class="o">=</span><span class="n">iz</span><span class="o">+</span><span class="mi">1</span>
   <span class="k">end do</span>

<span class="k">end subroutine </span><span class="n">initialize</span>

<span class="k">subroutine </span><span class="n">select_another_coeff_to_solve_for</span><span class="p">()</span>

   <span class="c">!! 1. Search through set z for a new coefficient to solve for.</span>
   <span class="c">!!    First select a candidate that is either an unconstrained</span>
   <span class="c">!!    coefficient or else a constrained coefficient that has room</span>
   <span class="c">!!    to move in the direction consistent with the sign of its dual</span>
   <span class="c">!!    vector component.  Components of the dual (negative gradient)</span>
   <span class="c">!!    vector will be computed as needed.</span>
   <span class="c">!! 2. For each candidate start the transformation to bring this</span>
   <span class="c">!!    candidate into the triangle, and then do two tests:  Test size</span>
   <span class="c">!!    of new diagonal value to avoid extreme ill-conditioning, and</span>
   <span class="c">!!    the value of this new coefficient to be sure it moved in the</span>
   <span class="c">!!    expected direction.</span>
   <span class="c">!! 3. If some coefficient passes all these conditions, set FIND = true,</span>
   <span class="c">!!    The index of the selected coefficient is J = INDEX(IZ).</span>
   <span class="c">!! 4. If no coefficient is selected, set FIND = false.</span>

   <span class="n">find</span> <span class="o">=</span> <span class="p">.</span><span class="n">false</span><span class="p">.</span>
   <span class="k">do </span><span class="n">iz</span><span class="o">=</span><span class="n">iz1</span><span class="p">,</span><span class="n">iz2</span>
      <span class="n">j</span><span class="o">=</span><span class="nb">index</span><span class="p">(</span><span class="n">iz</span><span class="p">)</span>

      <span class="c">! Set FREE1 = true if X(J) is not at the left end-point of its</span>
      <span class="c">! constraint region.</span>
      <span class="c">! Set FREE2 = true if X(J) is not at the right end-point of its</span>
      <span class="c">! constraint region.</span>
      <span class="c">! Set FREE = true if X(J) is not at either end-point of its</span>
      <span class="c">! constraint region.</span>

     <span class="n">free1</span> <span class="o">=</span> <span class="n">x</span><span class="p">(</span><span class="n">j</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">bnd</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="n">j</span><span class="p">)</span>
     <span class="n">free2</span> <span class="o">=</span> <span class="n">x</span><span class="p">(</span><span class="n">j</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">bnd</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="n">j</span><span class="p">)</span>
     <span class="n">free</span> <span class="o">=</span> <span class="n">free1</span> <span class="p">.</span><span class="nb">and</span><span class="p">.</span> <span class="n">free2</span>

     <span class="k">if</span> <span class="p">(</span> <span class="n">free</span> <span class="p">)</span> <span class="k">then</span>
<span class="k">        call </span><span class="n">test_coef_j_for_diag_elt_and_direction_of_change</span><span class="p">()</span>
     <span class="k">else</span>
        <span class="c">! Compute dual coefficient W(J).</span>
        <span class="n">w</span><span class="p">(</span><span class="n">j</span><span class="p">)</span><span class="o">=</span><span class="nb">dot_product</span><span class="p">(</span><span class="n">a</span><span class="p">(</span><span class="n">npp1</span><span class="p">:</span><span class="n">m</span><span class="p">,</span><span class="n">j</span><span class="p">),</span><span class="n">b</span><span class="p">(</span><span class="n">npp1</span><span class="p">:</span><span class="n">m</span><span class="p">))</span>

        <span class="c">! Can X(J) move in the direction indicated by the sign of W(J)?</span>
        <span class="k">if</span> <span class="p">(</span> <span class="n">w</span><span class="p">(</span><span class="n">j</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">zero</span> <span class="p">)</span> <span class="k">then</span>
<span class="k">           if</span> <span class="p">(</span> <span class="n">free1</span> <span class="p">)</span> <span class="k">call </span><span class="n">test_coef_j_for_diag_elt_and_direction_of_change</span><span class="p">()</span>
        <span class="k">else  if</span> <span class="p">(</span> <span class="n">w</span><span class="p">(</span><span class="n">j</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">zero</span> <span class="p">)</span> <span class="k">then</span>
<span class="k">           if</span> <span class="p">(</span> <span class="n">free2</span> <span class="p">)</span> <span class="k">call </span><span class="n">test_coef_j_for_diag_elt_and_direction_of_change</span><span class="p">()</span>
        <span class="k">end if</span>
<span class="k">     end if</span>
<span class="k">     if</span> <span class="p">(</span> <span class="n">find</span> <span class="p">)</span> <span class="k">return</span>
<span class="k">   end do</span>

<span class="k">end subroutine </span><span class="n">select_another_coeff_to_solve_for</span>

<span class="k">subroutine </span><span class="n">test_coef_j_for_diag_elt_and_direction_of_change</span><span class="p">()</span>

   <span class="c">!! The sign of W(J) is OK for J to be moved to set P.</span>
   <span class="c">!! Begin the transformation and check new diagonal element to avoid</span>
   <span class="c">!! near linear dependence.</span>

   <span class="n">asave</span><span class="o">=</span><span class="n">a</span><span class="p">(</span><span class="n">npp1</span><span class="p">,</span><span class="n">j</span><span class="p">)</span>
   <span class="k">call </span><span class="n">htc</span> <span class="p">(</span><span class="n">npp1</span><span class="p">,</span> <span class="n">a</span><span class="p">(</span><span class="mi">1</span><span class="p">:</span><span class="n">m</span><span class="p">,</span><span class="n">j</span><span class="p">),</span> <span class="n">up</span><span class="p">)</span>
   <span class="n">unorm</span> <span class="o">=</span> <span class="n">nrm2</span><span class="p">(</span><span class="n">a</span><span class="p">(</span><span class="mi">1</span><span class="p">:</span><span class="n">nsetp</span><span class="p">,</span><span class="n">j</span><span class="p">))</span>
   <span class="k">if</span> <span class="p">(</span> <span class="nb">abs</span><span class="p">(</span><span class="n">a</span><span class="p">(</span><span class="n">npp1</span><span class="p">,</span><span class="n">j</span><span class="p">))</span> <span class="o">&gt;</span> <span class="n">eps</span> <span class="o">*</span> <span class="n">unorm</span><span class="p">)</span> <span class="k">then</span>

      <span class="c">! Column J is sufficiently independent.  Copy b into Z, update Z.</span>
      <span class="n">z</span><span class="p">(</span><span class="mi">1</span><span class="p">:</span><span class="n">m</span><span class="p">)</span><span class="o">=</span><span class="n">b</span><span class="p">(</span><span class="mi">1</span><span class="p">:</span><span class="n">m</span><span class="p">)</span>
      <span class="c">! Compute product of transormation and updated right-hand side.</span>
      <span class="n">norm</span><span class="o">=</span><span class="n">a</span><span class="p">(</span><span class="n">npp1</span><span class="p">,</span><span class="n">j</span><span class="p">)</span>
      <span class="n">a</span><span class="p">(</span><span class="n">npp1</span><span class="p">,</span><span class="n">j</span><span class="p">)</span><span class="o">=</span><span class="n">up</span>
      <span class="k">if</span> <span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">norm</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">zero</span><span class="p">)</span> <span class="k">then</span>
<span class="k">         </span><span class="n">sm</span><span class="o">=</span><span class="nb">dot_product</span><span class="p">(</span><span class="n">a</span><span class="p">(</span><span class="n">npp1</span><span class="p">:</span><span class="n">m</span><span class="p">,</span><span class="n">j</span><span class="p">)</span><span class="o">/</span><span class="n">norm</span><span class="p">,</span> <span class="n">z</span><span class="p">(</span><span class="n">npp1</span><span class="p">:</span><span class="n">m</span><span class="p">))</span><span class="o">/</span><span class="n">up</span>
         <span class="n">z</span><span class="p">(</span><span class="n">npp1</span><span class="p">:</span><span class="n">m</span><span class="p">)</span><span class="o">=</span><span class="n">z</span><span class="p">(</span><span class="n">npp1</span><span class="p">:</span><span class="n">m</span><span class="p">)</span><span class="o">+</span><span class="n">sm</span><span class="o">*</span><span class="n">a</span><span class="p">(</span><span class="n">npp1</span><span class="p">:</span><span class="n">m</span><span class="p">,</span><span class="n">j</span><span class="p">)</span>
         <span class="n">a</span><span class="p">(</span><span class="n">npp1</span><span class="p">,</span><span class="n">j</span><span class="p">)</span><span class="o">=</span><span class="n">norm</span>
      <span class="k">end if</span>

<span class="k">      if</span> <span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">x</span><span class="p">(</span><span class="n">j</span><span class="p">))</span> <span class="o">&gt;</span>  <span class="n">zero</span><span class="p">)</span> <span class="n">z</span><span class="p">(</span><span class="mi">1</span><span class="p">:</span><span class="n">npp1</span><span class="p">)</span><span class="o">=</span><span class="n">z</span><span class="p">(</span><span class="mi">1</span><span class="p">:</span><span class="n">npp1</span><span class="p">)</span><span class="o">+</span><span class="n">a</span><span class="p">(</span><span class="mi">1</span><span class="p">:</span><span class="n">npp1</span><span class="p">,</span><span class="n">j</span><span class="p">)</span><span class="o">*</span><span class="n">x</span><span class="p">(</span><span class="n">j</span><span class="p">)</span>
      <span class="c">! Adjust Z() as though X(J) had been reset to zero.</span>
      <span class="k">if</span> <span class="p">(</span> <span class="n">free</span> <span class="p">)</span> <span class="k">then</span>
<span class="k">         </span><span class="n">find</span> <span class="o">=</span> <span class="p">.</span><span class="n">true</span><span class="p">.</span>
      <span class="k">else</span>
         <span class="c">!! Solve for ZTEST ( proposed new value for X(J) ).</span>
         <span class="c">!! Then set FIND to indicate if ZTEST has moved away from X(J) in</span>
         <span class="c">!! the expected direction indicated by the sign of W(J).</span>
         <span class="n">ztest</span><span class="o">=</span><span class="n">z</span><span class="p">(</span><span class="n">npp1</span><span class="p">)</span><span class="o">/</span><span class="n">a</span><span class="p">(</span><span class="n">npp1</span><span class="p">,</span><span class="n">j</span><span class="p">)</span>
         <span class="n">find</span> <span class="o">=</span> <span class="p">(</span> <span class="n">w</span><span class="p">(</span><span class="n">j</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">zero</span>  <span class="p">.</span><span class="nb">and</span><span class="p">.</span>  <span class="n">ztest</span> <span class="o">&lt;</span> <span class="n">x</span><span class="p">(</span><span class="n">j</span><span class="p">)</span> <span class="p">)</span> <span class="p">.</span><span class="nb">or</span><span class="p">.</span> <span class="p">&amp;</span>
                <span class="p">(</span> <span class="n">w</span><span class="p">(</span><span class="n">j</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">zero</span>  <span class="p">.</span><span class="nb">and</span><span class="p">.</span>  <span class="n">ztest</span> <span class="o">&gt;</span> <span class="n">x</span><span class="p">(</span><span class="n">j</span><span class="p">)</span> <span class="p">)</span>
      <span class="k">end if</span>
<span class="k">   end if</span>

   <span class="c">! If J was not accepted to be moved from set Z to set P,</span>
   <span class="c">! restore A(NNP1,J).  Failing these tests may mean the computed</span>
   <span class="c">! sign of W(J) is suspect, so here we set W(J) = 0.  This will</span>
   <span class="c">! not affect subsequent computation, but cleans up the W() array.</span>
   <span class="k">if</span> <span class="p">(</span> <span class="p">.</span><span class="nb">not</span><span class="p">.</span> <span class="n">find</span> <span class="p">)</span> <span class="k">then</span>
<span class="k">      </span><span class="n">a</span><span class="p">(</span><span class="n">npp1</span><span class="p">,</span><span class="n">j</span><span class="p">)</span><span class="o">=</span><span class="n">asave</span>
      <span class="n">w</span><span class="p">(</span><span class="n">j</span><span class="p">)</span><span class="o">=</span><span class="n">zero</span>
   <span class="k">end if</span>

<span class="k">end subroutine </span><span class="n">test_coef_j_for_diag_elt_and_direction_of_change</span>

<span class="k">subroutine </span><span class="n">move_j_from_set_z_to_set_p</span><span class="p">()</span>

   <span class="c">!! The index  J=index(IZ)  has been selected to be moved from</span>
   <span class="c">!! set Z to set P.  Z() contains the old B() adjusted as though X(J) = 0.</span>
   <span class="c">!! A(*,J) contains the new Householder transformation vector.</span>

   <span class="n">b</span><span class="p">(</span><span class="mi">1</span><span class="p">:</span><span class="n">m</span><span class="p">)</span><span class="o">=</span><span class="n">z</span><span class="p">(</span><span class="mi">1</span><span class="p">:</span><span class="n">m</span><span class="p">)</span>
   <span class="nb">index</span><span class="p">(</span><span class="n">iz</span><span class="p">)</span><span class="o">=</span><span class="nb">index</span><span class="p">(</span><span class="n">iz1</span><span class="p">)</span>
   <span class="nb">index</span><span class="p">(</span><span class="n">iz1</span><span class="p">)</span><span class="o">=</span><span class="n">j</span>
   <span class="n">iz1</span><span class="o">=</span><span class="n">iz1</span><span class="o">+</span><span class="mi">1</span>
   <span class="n">nsetp</span><span class="o">=</span><span class="n">npp1</span>
   <span class="n">npp1</span><span class="o">=</span><span class="n">npp1</span><span class="o">+</span><span class="mi">1</span>
   <span class="c">! The following loop can be null or not required.</span>
   <span class="n">norm</span><span class="o">=</span><span class="n">a</span><span class="p">(</span><span class="n">nsetp</span><span class="p">,</span><span class="n">j</span><span class="p">)</span>
   <span class="n">a</span><span class="p">(</span><span class="n">nsetp</span><span class="p">,</span><span class="n">j</span><span class="p">)</span><span class="o">=</span><span class="n">up</span>
   <span class="k">if</span> <span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">norm</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">zero</span><span class="p">)</span> <span class="k">then</span>
<span class="k">      do </span><span class="n">jz</span><span class="o">=</span><span class="n">iz1</span><span class="p">,</span><span class="n">iz2</span>
         <span class="n">jj</span><span class="o">=</span><span class="nb">index</span><span class="p">(</span><span class="n">jz</span><span class="p">)</span>
         <span class="n">sm</span><span class="o">=</span><span class="nb">dot_product</span><span class="p">(</span><span class="n">a</span><span class="p">(</span><span class="n">nsetp</span><span class="p">:</span><span class="n">m</span><span class="p">,</span><span class="n">j</span><span class="p">)</span><span class="o">/</span><span class="n">norm</span><span class="p">,</span> <span class="n">a</span><span class="p">(</span><span class="n">nsetp</span><span class="p">:</span><span class="n">m</span><span class="p">,</span><span class="n">jj</span><span class="p">))</span><span class="o">/</span><span class="n">up</span>
         <span class="n">a</span><span class="p">(</span><span class="n">nsetp</span><span class="p">:</span><span class="n">m</span><span class="p">,</span><span class="n">jj</span><span class="p">)</span><span class="o">=</span><span class="n">a</span><span class="p">(</span><span class="n">nsetp</span><span class="p">:</span><span class="n">m</span><span class="p">,</span><span class="n">jj</span><span class="p">)</span><span class="o">+</span><span class="n">sm</span><span class="o">*</span><span class="n">a</span><span class="p">(</span><span class="n">nsetp</span><span class="p">:</span><span class="n">m</span><span class="p">,</span><span class="n">j</span><span class="p">)</span>
      <span class="k">end do</span>
<span class="k">   </span><span class="n">a</span><span class="p">(</span><span class="n">nsetp</span><span class="p">,</span><span class="n">j</span><span class="p">)</span><span class="o">=</span><span class="n">norm</span>
   <span class="k">end if</span>
   <span class="c">! The following loop can be null.</span>
   <span class="k">do </span><span class="n">l</span><span class="o">=</span><span class="n">npp1</span><span class="p">,</span><span class="n">m</span>
      <span class="n">a</span><span class="p">(</span><span class="n">l</span><span class="p">,</span><span class="n">j</span><span class="p">)</span><span class="o">=</span><span class="n">zero</span>
   <span class="k">end do</span><span class="c">!  L</span>

   <span class="n">w</span><span class="p">(</span><span class="n">j</span><span class="p">)</span><span class="o">=</span><span class="n">zero</span>

   <span class="c">! Solve the triangular system.  Store this solution temporarily in Z().</span>
   <span class="k">do </span><span class="n">i</span> <span class="o">=</span> <span class="n">nsetp</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">/=</span> <span class="n">nsetp</span><span class="p">)</span> <span class="n">z</span><span class="p">(</span><span class="mi">1</span><span class="p">:</span><span class="n">i</span><span class="p">)</span><span class="o">=</span><span class="n">z</span><span class="p">(</span><span class="mi">1</span><span class="p">:</span><span class="n">i</span><span class="p">)</span><span class="o">-</span><span class="n">a</span><span class="p">(</span><span class="mi">1</span><span class="p">:</span><span class="n">i</span><span class="p">,</span><span class="n">ii</span><span class="p">)</span><span class="o">*</span><span class="n">z</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
      <span class="n">ii</span><span class="o">=</span><span class="nb">index</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
      <span class="n">z</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="o">=</span><span class="n">z</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="o">/</span><span class="n">a</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">ii</span><span class="p">)</span>
   <span class="k">end do</span>

<span class="k">end subroutine </span><span class="n">move_j_from_set_z_to_set_p</span>

<span class="k">subroutine </span><span class="n">test_set_p_against_constraints</span><span class="p">()</span>

   <span class="n">loopb</span><span class="p">:</span> <span class="k">do</span>
      <span class="c">! The solution obtained by solving the current set P is in the array Z().</span>

      <span class="n">iter</span><span class="o">=</span><span class="n">iter</span><span class="o">+</span><span class="mi">1</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">iter</span> <span class="o">&gt;</span> <span class="n">itmax</span><span class="p">)</span> <span class="k">then</span>
<span class="k">         </span><span class="n">ierr</span> <span class="o">=</span> <span class="mi">4</span>
         <span class="k">exit </span><span class="n">loopb</span>
      <span class="k">end if</span>

<span class="k">      call </span><span class="n">see_if_all_constrained_coeffs_are_feasible</span><span class="p">()</span>

      <span class="c">! The above call sets HITBND.  If HITBND = true then it also sets</span>
      <span class="c">! ALPHA, JJ, and IBOUND.</span>
      <span class="k">if</span> <span class="p">(</span> <span class="p">.</span><span class="nb">not</span><span class="p">.</span> <span class="n">hitbnd</span> <span class="p">)</span> <span class="k">exit </span><span class="n">loopb</span>

      <span class="c">! Here ALPHA will be between 0 and 1 for interpolation</span>
      <span class="c">! between the old X() and the new Z().</span>
      <span class="k">do </span><span class="n">ip</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span><span class="n">nsetp</span>
         <span class="n">l</span><span class="o">=</span><span class="nb">index</span><span class="p">(</span><span class="n">ip</span><span class="p">)</span>
         <span class="n">x</span><span class="p">(</span><span class="n">l</span><span class="p">)</span><span class="o">=</span><span class="n">x</span><span class="p">(</span><span class="n">l</span><span class="p">)</span><span class="o">+</span><span class="n">alpha</span><span class="o">*</span><span class="p">(</span><span class="n">z</span><span class="p">(</span><span class="n">ip</span><span class="p">)</span><span class="o">-</span><span class="n">x</span><span class="p">(</span><span class="n">l</span><span class="p">))</span>
      <span class="k">end do</span>

<span class="k">      </span><span class="n">i</span><span class="o">=</span><span class="nb">index</span><span class="p">(</span><span class="n">jj</span><span class="p">)</span>
      <span class="c">! Note:  The exit test is done at the end of the loop, so the loop</span>
      <span class="c">! will always be executed at least once.</span>
      <span class="k">do</span>

         <span class="c">! Modify A(*,*), B(*) and the index arrays to move coefficient I</span>
         <span class="c">! from set P to set Z.</span>

         <span class="k">call </span><span class="n">move_coef_i_from_set_p_to_set_z</span>

         <span class="k">if</span> <span class="p">(</span><span class="n">nsetp</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="k">exit </span><span class="n">loopb</span>

         <span class="c">! See if the remaining coefficients in set P are feasible.  They should</span>
         <span class="c">! be because of the way ALPHA was determined.  If any are infeasible</span>
         <span class="c">! it is due to round-off error.  Any that are infeasible or on a boundary</span>
         <span class="c">! will be set to the boundary value and moved from set P to set Z.</span>

          <span class="n">ibound</span> <span class="o">=</span> <span class="mi">0</span>
          <span class="k">do </span><span class="n">jj</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span><span class="n">nsetp</span>
             <span class="n">i</span><span class="o">=</span><span class="nb">index</span><span class="p">(</span><span class="n">jj</span><span class="p">)</span>
             <span class="k">if</span> <span class="p">(</span> <span class="n">x</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">bnd</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="n">i</span><span class="p">))</span> <span class="k">then</span>
<span class="k">                 </span><span class="n">ibound</span><span class="o">=</span><span class="mi">1</span>
                 <span class="k">exit</span>
<span class="k">             else if</span> <span class="p">(</span> <span class="n">x</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="n">bnd</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="n">i</span><span class="p">))</span> <span class="k">then</span>
<span class="k">                 </span><span class="n">ibound</span><span class="o">=</span><span class="mi">2</span>
                 <span class="k">exit</span>
<span class="k">             end if</span>
<span class="k">         end do</span>
<span class="k">         if</span> <span class="p">(</span><span class="n">ibound</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="k">exit</span>
<span class="k">      end do</span>

      <span class="c">! Copy B( ) into Z( ).  Then solve again and loop back.</span>
      <span class="n">z</span><span class="p">(</span><span class="mi">1</span><span class="p">:</span><span class="n">m</span><span class="p">)</span><span class="o">=</span><span class="n">b</span><span class="p">(</span><span class="mi">1</span><span class="p">:</span><span class="n">m</span><span class="p">)</span>

      <span class="k">do </span><span class="n">i</span> <span class="o">=</span> <span class="n">nsetp</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span>
         <span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">/=</span> <span class="n">nsetp</span><span class="p">)</span> <span class="n">z</span><span class="p">(</span><span class="mi">1</span><span class="p">:</span><span class="n">i</span><span class="p">)</span><span class="o">=</span><span class="n">z</span><span class="p">(</span><span class="mi">1</span><span class="p">:</span><span class="n">i</span><span class="p">)</span><span class="o">-</span><span class="n">a</span><span class="p">(</span><span class="mi">1</span><span class="p">:</span><span class="n">i</span><span class="p">,</span><span class="n">ii</span><span class="p">)</span><span class="o">*</span><span class="n">z</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
         <span class="n">ii</span><span class="o">=</span><span class="nb">index</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
         <span class="n">z</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="o">=</span><span class="n">z</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="o">/</span><span class="n">a</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">ii</span><span class="p">)</span>
      <span class="k">end do</span>
<span class="k">   end do </span><span class="n">loopb</span>

   <span class="c">! The following loop can be null.</span>
   <span class="k">do </span><span class="n">ip</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span><span class="n">nsetp</span>
      <span class="n">i</span><span class="o">=</span><span class="nb">index</span><span class="p">(</span><span class="n">ip</span><span class="p">)</span>
      <span class="n">x</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="o">=</span><span class="n">z</span><span class="p">(</span><span class="n">ip</span><span class="p">)</span>
   <span class="k">end do</span>

<span class="k">end subroutine </span><span class="n">test_set_p_against_constraints</span>

<span class="k">subroutine </span><span class="n">see_if_all_constrained_coeffs_are_feasible</span><span class="p">()</span>

   <span class="c">!! See if each coefficient in set P is strictly interior to its constraint region.</span>
   <span class="c">!! If so, set HITBND = false.</span>
   <span class="c">!! If not, set HITBND = true, and also set ALPHA, JJ, and IBOUND.</span>
   <span class="c">!! Then ALPHA will satisfy  0.  &lt; ALPHA  &lt;=  1.</span>

   <span class="n">alpha</span><span class="o">=</span><span class="n">two</span>
   <span class="k">do </span><span class="n">ip</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span><span class="n">nsetp</span>
      <span class="n">l</span><span class="o">=</span><span class="nb">index</span><span class="p">(</span><span class="n">ip</span><span class="p">)</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">z</span><span class="p">(</span><span class="n">ip</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">bnd</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="n">l</span><span class="p">))</span> <span class="k">then</span>
         <span class="c">! Z(IP) HITS LOWER BOUND</span>
         <span class="nb">lbound</span><span class="o">=</span><span class="mi">1</span>
      <span class="k">else  if</span> <span class="p">(</span><span class="n">z</span><span class="p">(</span><span class="n">ip</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="n">bnd</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="n">l</span><span class="p">))</span> <span class="k">then</span>
         <span class="c">! Z(IP) HITS UPPER BOUND</span>
         <span class="nb">lbound</span><span class="o">=</span><span class="mi">2</span>
      <span class="k">else</span>
<span class="k">         </span><span class="nb">lbound</span> <span class="o">=</span> <span class="mi">0</span>
      <span class="k">end if</span>

<span class="k">      if</span> <span class="p">(</span> <span class="nb">lbound</span> <span class="o">/=</span> <span class="mi">0</span> <span class="p">)</span> <span class="k">then</span>
<span class="k">         </span><span class="n">t</span><span class="o">=</span><span class="p">(</span><span class="n">bnd</span><span class="p">(</span><span class="nb">lbound</span><span class="p">,</span><span class="n">l</span><span class="p">)</span><span class="o">-</span><span class="n">x</span><span class="p">(</span><span class="n">l</span><span class="p">))</span><span class="o">/</span><span class="p">(</span><span class="n">z</span><span class="p">(</span><span class="n">ip</span><span class="p">)</span><span class="o">-</span><span class="n">x</span><span class="p">(</span><span class="n">l</span><span class="p">))</span>
         <span class="k">if</span> <span class="p">(</span><span class="n">alpha</span> <span class="o">&gt;</span> <span class="n">t</span><span class="p">)</span> <span class="k">then</span>
<span class="k">           </span><span class="n">alpha</span><span class="o">=</span><span class="n">t</span>
           <span class="n">jj</span><span class="o">=</span><span class="n">ip</span>
           <span class="n">ibound</span><span class="o">=</span><span class="nb">lbound</span>
<span class="nb">         </span><span class="k">end if</span>
<span class="k">      end if</span>
<span class="k">   end do</span>
<span class="k">   </span><span class="n">hitbnd</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">alpha</span> <span class="o">-</span> <span class="n">two</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">zero</span>

<span class="k">end subroutine </span><span class="n">see_if_all_constrained_coeffs_are_feasible</span>

<span class="k">subroutine </span><span class="n">move_coef_i_from_set_p_to_set_z</span><span class="p">()</span>

   <span class="n">x</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="o">=</span><span class="n">bnd</span><span class="p">(</span><span class="n">ibound</span><span class="p">,</span><span class="n">i</span><span class="p">)</span>
   <span class="k">if</span> <span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">x</span><span class="p">(</span><span class="n">i</span><span class="p">))</span> <span class="o">&gt;</span> <span class="n">zero</span> <span class="p">.</span><span class="nb">and</span><span class="p">.</span> <span class="n">jj</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="n">b</span><span class="p">(</span><span class="mi">1</span><span class="p">:</span><span class="n">jj</span><span class="p">)</span><span class="o">=</span><span class="n">b</span><span class="p">(</span><span class="mi">1</span><span class="p">:</span><span class="n">jj</span><span class="p">)</span><span class="o">-</span><span class="n">a</span><span class="p">(</span><span class="mi">1</span><span class="p">:</span><span class="n">jj</span><span class="p">,</span><span class="n">i</span><span class="p">)</span><span class="o">*</span><span class="n">x</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>

   <span class="c">! The following loop can be null.</span>
   <span class="k">do </span><span class="n">j</span> <span class="o">=</span> <span class="n">jj</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">nsetp</span>
      <span class="n">ii</span><span class="o">=</span><span class="nb">index</span><span class="p">(</span><span class="n">j</span><span class="p">)</span>
      <span class="nb">index</span><span class="p">(</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">=</span><span class="n">ii</span>
      <span class="k">call </span><span class="n">rotg</span> <span class="p">(</span><span class="n">a</span><span class="p">(</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">ii</span><span class="p">),</span><span class="n">a</span><span class="p">(</span><span class="n">j</span><span class="p">,</span><span class="n">ii</span><span class="p">),</span><span class="n">cc</span><span class="p">,</span><span class="n">ss</span><span class="p">)</span>
      <span class="n">sm</span><span class="o">=</span><span class="n">a</span><span class="p">(</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">ii</span><span class="p">)</span>
      <span class="c">! The plane rotation is applied to two rows of A and the right-hand</span>
      <span class="c">! side.  One row is moved to the scratch array S and then the updates</span>
      <span class="c">! are computed.  The intent is for array operations to be performed</span>
      <span class="c">! and minimal extra data movement.  One extra rotation is applied</span>
      <span class="c">! to column II in this approach.</span>
      <span class="n">s</span><span class="o">=</span><span class="n">a</span><span class="p">(</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">:</span><span class="n">n</span><span class="p">)</span>
      <span class="n">a</span><span class="p">(</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">:</span><span class="n">n</span><span class="p">)</span><span class="o">=</span><span class="n">cc</span><span class="o">*</span><span class="n">s</span><span class="o">+</span><span class="n">ss</span><span class="o">*</span><span class="n">a</span><span class="p">(</span><span class="n">j</span><span class="p">,</span><span class="mi">1</span><span class="p">:</span><span class="n">n</span><span class="p">)</span>
      <span class="n">a</span><span class="p">(</span><span class="n">j</span><span class="p">,</span><span class="mi">1</span><span class="p">:</span><span class="n">n</span><span class="p">)</span><span class="o">=</span><span class="n">cc</span><span class="o">*</span><span class="n">a</span><span class="p">(</span><span class="n">j</span><span class="p">,</span><span class="mi">1</span><span class="p">:</span><span class="n">n</span><span class="p">)</span><span class="o">-</span><span class="n">ss</span><span class="o">*</span><span class="n">s</span>
      <span class="n">a</span><span class="p">(</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">ii</span><span class="p">)</span><span class="o">=</span><span class="n">sm</span>
      <span class="n">a</span><span class="p">(</span><span class="n">j</span><span class="p">,</span><span class="n">ii</span><span class="p">)</span><span class="o">=</span><span class="n">zero</span>
      <span class="n">sm</span><span class="o">=</span><span class="n">b</span><span class="p">(</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
      <span class="n">b</span><span class="p">(</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">=</span><span class="n">cc</span><span class="o">*</span><span class="n">sm</span><span class="o">+</span><span class="n">ss</span><span class="o">*</span><span class="n">b</span><span class="p">(</span><span class="n">j</span><span class="p">)</span>
      <span class="n">b</span><span class="p">(</span><span class="n">j</span><span class="p">)</span><span class="o">=</span><span class="n">cc</span><span class="o">*</span><span class="n">b</span><span class="p">(</span><span class="n">j</span><span class="p">)</span><span class="o">-</span><span class="n">ss</span><span class="o">*</span><span class="n">sm</span>
   <span class="k">end do</span>

<span class="k">   </span><span class="n">npp1</span><span class="o">=</span><span class="n">nsetp</span>
   <span class="n">nsetp</span><span class="o">=</span><span class="n">nsetp</span><span class="o">-</span><span class="mi">1</span>
   <span class="n">iz1</span><span class="o">=</span><span class="n">iz1</span><span class="o">-</span><span class="mi">1</span>
   <span class="nb">index</span><span class="p">(</span><span class="n">iz1</span><span class="p">)</span><span class="o">=</span><span class="n">i</span>

<span class="k">end subroutine </span><span class="n">move_coef_i_from_set_p_to_set_z</span>

<span class="k">subroutine </span><span class="n">termination</span><span class="p">()</span>

   <span class="k">if</span> <span class="p">(</span><span class="n">ierr</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="k">then</span>
      <span class="c">! Compute the norm of the residual vector.</span>
      <span class="n">sm</span><span class="o">=</span><span class="n">zero</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">npp1</span> <span class="o">&lt;=</span> <span class="n">m</span><span class="p">)</span> <span class="k">then</span>
<span class="k">         </span><span class="n">sm</span><span class="o">=</span><span class="n">nrm2</span><span class="p">(</span><span class="n">b</span><span class="p">(</span><span class="n">npp1</span><span class="p">:</span><span class="n">m</span><span class="p">))</span>
      <span class="k">else</span>
<span class="k">         </span><span class="n">w</span><span class="p">(</span><span class="mi">1</span><span class="p">:</span><span class="n">n</span><span class="p">)</span><span class="o">=</span><span class="n">zero</span>
      <span class="k">end if</span>
<span class="k">      </span><span class="n">rnorm</span><span class="o">=</span><span class="n">sm</span>
   <span class="k">end if</span>

<span class="k">end subroutine </span><span class="n">termination</span>

<span class="k">pure subroutine </span><span class="n">rotg</span><span class="p">(</span><span class="n">sa</span><span class="p">,</span><span class="n">sb</span><span class="p">,</span><span class="n">c</span><span class="p">,</span><span class="n">s</span><span class="p">)</span>

   <span class="kt">real</span><span class="p">(</span><span class="n">wp</span><span class="p">),</span><span class="k">intent</span><span class="p">(</span><span class="n">inout</span><span class="p">)</span> <span class="kd">::</span> <span class="n">sa</span>
   <span class="kt">real</span><span class="p">(</span><span class="n">wp</span><span class="p">),</span><span class="k">intent</span><span class="p">(</span><span class="n">in</span><span class="p">)</span>    <span class="kd">::</span> <span class="n">sb</span>
   <span class="kt">real</span><span class="p">(</span><span class="n">wp</span><span class="p">),</span><span class="k">intent</span><span class="p">(</span><span class="n">out</span><span class="p">)</span>   <span class="kd">::</span> <span class="n">c</span>
   <span class="kt">real</span><span class="p">(</span><span class="n">wp</span><span class="p">),</span><span class="k">intent</span><span class="p">(</span><span class="n">out</span><span class="p">)</span>   <span class="kd">::</span> <span class="n">s</span>

   <span class="kt">real</span><span class="p">(</span><span class="n">wp</span><span class="p">)</span> <span class="kd">::</span> <span class="n">roe</span><span class="p">,</span><span class="nb">scale</span><span class="p">,</span><span class="n">r</span>

   <span class="n">roe</span> <span class="o">=</span> <span class="n">sb</span>
   <span class="k">if</span> <span class="p">(</span> <span class="nb">abs</span><span class="p">(</span><span class="n">sa</span><span class="p">)</span> <span class="o">&gt;</span> <span class="nb">abs</span><span class="p">(</span><span class="n">sb</span><span class="p">)</span> <span class="p">)</span> <span class="n">roe</span> <span class="o">=</span> <span class="n">sa</span>
   <span class="nb">scale</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">sa</span><span class="p">)</span> <span class="o">+</span> <span class="nb">abs</span><span class="p">(</span><span class="n">sb</span><span class="p">)</span>
   <span class="k">if</span> <span class="p">(</span> <span class="nb">scale</span> <span class="o">&lt;=</span> <span class="n">zero</span> <span class="p">)</span> <span class="k">then</span>
<span class="k">      </span><span class="n">c</span> <span class="o">=</span> <span class="n">one</span>
      <span class="n">s</span> <span class="o">=</span> <span class="n">zero</span>
   <span class="k">else</span>
<span class="k">      </span><span class="n">r</span> <span class="o">=</span> <span class="nb">scale</span><span class="o">*</span><span class="nb">sqrt</span><span class="p">((</span><span class="n">sa</span><span class="o">/</span><span class="nb">scale</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="p">(</span><span class="n">sb</span><span class="o">/</span><span class="nb">scale</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">roe</span> <span class="o">&lt;</span> <span class="n">zero</span><span class="p">)</span> <span class="n">r</span><span class="o">=-</span><span class="n">r</span>
      <span class="n">c</span> <span class="o">=</span> <span class="n">sa</span><span class="o">/</span><span class="n">r</span>
      <span class="n">s</span> <span class="o">=</span> <span class="n">sb</span><span class="o">/</span><span class="n">r</span>
      <span class="n">sa</span> <span class="o">=</span> <span class="n">r</span>
   <span class="k">end if</span>

<span class="k">end subroutine </span><span class="n">rotg</span>

<span class="k">pure function </span><span class="n">nrm2</span> <span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">result</span><span class="p">(</span><span class="n">norm</span><span class="p">)</span>

   <span class="c">!!  NRM2 returns the Euclidean norm of a vector via the function</span>
   <span class="c">!!  name, so that</span>
   <span class="c">!!</span>
   <span class="c">!!  `NRM2 := sqrt( x&#39;*x )`</span>
   <span class="c">!!</span>
   <span class="c">!!### See also</span>
   <span class="c">!!  * [[dnrm2]]</span>

   <span class="kt">real</span><span class="p">(</span><span class="n">wp</span><span class="p">),</span><span class="k">dimension</span><span class="p">(:),</span><span class="k">intent</span><span class="p">(</span><span class="n">in</span><span class="p">)</span> <span class="kd">::</span> <span class="n">x</span>
   <span class="kt">real</span><span class="p">(</span><span class="n">wp</span><span class="p">)</span> <span class="kd">::</span> <span class="n">norm</span>

   <span class="kt">real</span><span class="p">(</span><span class="n">wp</span><span class="p">)</span> <span class="kd">::</span> <span class="n">absxi</span><span class="p">,</span> <span class="nb">scale</span><span class="p">,</span> <span class="n">ssq</span>
   <span class="kt">integer</span> <span class="kd">::</span> <span class="n">n</span><span class="p">,</span> <span class="n">ix</span>

   <span class="n">n</span><span class="o">=</span><span class="n">size</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
   <span class="k">if</span> <span class="p">(</span> <span class="n">n</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">)</span> <span class="k">then</span>
<span class="k">      </span><span class="n">norm</span>  <span class="o">=</span> <span class="n">zero</span>
   <span class="k">else if</span> <span class="p">(</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">1</span> <span class="p">)</span> <span class="k">then</span>
<span class="k">      </span><span class="n">norm</span>  <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span> <span class="n">x</span><span class="p">(</span> <span class="mi">1</span> <span class="p">)</span> <span class="p">)</span>
   <span class="k">else</span>
<span class="k">      </span><span class="nb">scale</span> <span class="o">=</span> <span class="n">zero</span>
      <span class="n">ssq</span>   <span class="o">=</span> <span class="n">one</span>
      <span class="k">do </span><span class="n">ix</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">n</span>
         <span class="n">absxi</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span> <span class="n">x</span><span class="p">(</span> <span class="n">ix</span> <span class="p">)</span> <span class="p">)</span>
          <span class="k">if</span> <span class="p">(</span><span class="n">absxi</span> <span class="o">&gt;</span> <span class="n">zero</span> <span class="p">)</span> <span class="k">then</span>
<span class="k">             if</span> <span class="p">(</span> <span class="nb">scale</span> <span class="o">&lt;</span> <span class="n">absxi</span> <span class="p">)</span> <span class="k">then</span>
<span class="k">                </span><span class="n">ssq</span>   <span class="o">=</span> <span class="n">one</span> <span class="o">+</span> <span class="n">ssq</span><span class="o">*</span><span class="p">(</span> <span class="nb">scale</span><span class="o">/</span><span class="n">absxi</span> <span class="p">)</span><span class="o">**</span><span class="mi">2</span>
                <span class="nb">scale</span> <span class="o">=</span> <span class="n">absxi</span>
             <span class="k">else</span>
<span class="k">                </span><span class="n">ssq</span>   <span class="o">=</span> <span class="n">ssq</span> <span class="o">+</span> <span class="p">(</span> <span class="n">absxi</span><span class="o">/</span><span class="nb">scale</span> <span class="p">)</span><span class="o">**</span><span class="mi">2</span>
             <span class="k">end if</span>
<span class="k">         end if</span>
<span class="k">     end do</span>
<span class="k">     </span><span class="n">norm</span>  <span class="o">=</span> <span class="nb">scale</span> <span class="o">*</span> <span class="nb">sqrt</span><span class="p">(</span> <span class="n">ssq</span> <span class="p">)</span>
   <span class="k">end if</span>

<span class="k">end function </span><span class="n">nrm2</span>

<span class="k">pure subroutine </span><span class="n">htc</span> <span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">up</span><span class="p">)</span>

   <span class="c">!! Construct a Householder transformation.</span>

   <span class="kt">integer</span><span class="p">,</span><span class="k">intent</span><span class="p">(</span><span class="n">in</span><span class="p">)</span>  <span class="kd">::</span> <span class="n">p</span>
   <span class="kt">real</span><span class="p">(</span><span class="n">wp</span><span class="p">),</span><span class="k">dimension</span><span class="p">(:),</span><span class="k">intent</span><span class="p">(</span><span class="n">inout</span><span class="p">)</span> <span class="kd">::</span> <span class="n">u</span>
   <span class="kt">real</span><span class="p">(</span><span class="n">wp</span><span class="p">),</span><span class="k">intent</span><span class="p">(</span><span class="n">out</span><span class="p">)</span> <span class="kd">::</span> <span class="n">up</span>

   <span class="kt">real</span><span class="p">(</span><span class="n">wp</span><span class="p">)</span> <span class="kd">::</span> <span class="n">vnorm</span>

   <span class="n">vnorm</span><span class="o">=</span><span class="n">nrm2</span><span class="p">(</span><span class="n">u</span><span class="p">(</span><span class="n">p</span><span class="p">:</span><span class="n">size</span><span class="p">(</span><span class="n">u</span><span class="p">)))</span>
   <span class="k">if</span> <span class="p">(</span><span class="n">u</span><span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">zero</span><span class="p">)</span> <span class="n">vnorm</span><span class="o">=-</span><span class="n">vnorm</span>
   <span class="n">up</span><span class="o">=</span><span class="n">u</span><span class="p">(</span><span class="n">p</span><span class="p">)</span><span class="o">-</span><span class="n">vnorm</span>
   <span class="n">u</span><span class="p">(</span><span class="n">p</span><span class="p">)</span><span class="o">=</span><span class="n">vnorm</span>

<span class="k">end subroutine </span><span class="n">htc</span>

<span class="k">end subroutine </span><span class="n">bvls</span>
</pre></div>

    </section>
    <br>
    
    
    </div>
  </div>


    <hr>    
    </div> <!-- /container -->
    <footer>
      <div class="container">
      <div class="row">
        <div class="col-xs-6 col-md-4"><p>&copy; 2019 
                                          </p></div>
        <div class="col-xs-6 col-md-4 col-md-push-4">
          <p class="text-right">
            Documentation generated by 
            <a href="https://github.com/cmacmackin/ford">FORD</a>
            
          </p>
        </div>
        <div class="col-xs-12 col-md-4 col-md-pull-4"><p class="text-center"> slsqp was developed by Jacob Williams</p></div>
      </div>
      <br>
      </div> <!-- /container -->    
    </footer>

    <!-- Bootstrap core JavaScript
    ================================================== -->
    <!-- Placed at the end of the document so the pages load faster -->
<!--
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.1/jquery.min.js"></script>
-->
    <script src="../js/bootstrap.min.js"></script>
    <!-- IE10 viewport hack for Surface/desktop Windows 8 bug -->
    <script src="../js/ie10-viewport-bug-workaround.js"></script>

    <!-- MathJax JavaScript
    ================================================== -->
    <!-- Placed at the end of the document so the pages load faster -->
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'AMS' } },
        jax: ['input/TeX','input/MathML','output/HTML-CSS'],
        extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js']
      });
    </script>
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    
    
    <script src="../tipuesearch/tipuesearch_content.js"></script>
    <script src="../tipuesearch/tipuesearch_set.js"></script>
    <script src="../tipuesearch/tipuesearch.js"></script>
    
    
  </body>
</html>